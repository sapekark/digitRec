
==================== FINAL INTERFACE ====================
2018-08-08 14:25:12.9480259 UTC

interface main:Training 8022
  interface hash: 5004e637e2b4418cbd4fd74d260df050
  ABI hash: a484d3acc28017b98a183b52aac299c0
  export-list hash: 71719dbbb374c9442345461a6dfa2921
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 301d5f8d0df098dd5e9c7328943f9dbc
  sig of: Nothing
  used TH splices: False
  where
exports:
  Training.cost'
  Training.deltas
  Training.learn
  Training.learningRate
  Training.revAcsWis
module dependencies: NeuralNetwork
package dependencies: Win32-2.5.4.1 array-0.5.2.0 base-4.10.1.0*
                      deepseq-1.4.3.0 ghc-prim-0.5.1.1 integer-gmp-1.0.1.0 random-1.1
                      time-1.8.0.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Complex base-4.10.1.0:Data.Either
                         base-4.10.1.0:Data.Functor.Compose base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Foldable 4349255461f1285ad885cd2301205c36
import  -/  base-4.10.1.0:Data.Functor b59a97e639e05373a94999f9bb899676
import  -/  base-4.10.1.0:Data.List e5312e282ad78d8152090e079f862b53
import  -/  base-4.10.1.0:Data.OldList fdea655c7bec488a3994df222c677ab7
import  -/  base-4.10.1.0:Data.Tuple ab0c62ebfcacf00dcba54934885c5064
import  -/  base-4.10.1.0:GHC.Base 8f949d675e49677c272f02ab7a85fe18
import  -/  base-4.10.1.0:GHC.List 1bb0adf79553530dc898796596e53188
import  -/  base-4.10.1.0:GHC.Num bee60808f8127e4cda82dd422aa1c6c0
import  -/  base-4.10.1.0:Prelude a93a9400cc0c816c2ee5f39399baa7a0
import  -/  ghc-prim-0.5.1.1:GHC.Classes 64ad5910d03ab188ab9b4adef7487b1e
import  -/  NeuralNetwork 01de0c92e2a8c1b8b2b2f7d968002413
  exports: 880191293dbf72c9005d5a2546c62fd5
  ActivationFunction 2321c528d82d4cd96aae6cc890f996f0
  NeuralNet 6efaf6673db0e5b81556d3abc3a4c697
  acFunc 2321c528d82d4cd96aae6cc890f996f0
  acFunc' 2321c528d82d4cd96aae6cc890f996f0
  computeLayer 6914b9a69dd3a08796c93c74b53f93e9
7dc1d7ec2d0ea53df7766e11f665f6b5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Training.$trModule3
                   Training.$trModule1) -}
3d5d6f6dedd0ef462132f163e98ecad2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Training.$trModule2) -}
2eec88c33f84b4ffa328b15c273ff768
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Training"#) -}
413c0e1fdd126c5f17d6de61aa5d12a3
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Training.$trModule4) -}
8ec4a0bc8a6607fd28d0ee501c502dda
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
9ed497a67d6f7d18e8230788770c37ab
  $wdeltas ::
    [GHC.Types.Double]
    -> [GHC.Types.Double]
    -> NeuralNetwork.NeuralNet
    -> NeuralNetwork.ActivationFunction
    -> (# [[GHC.Types.Double]], [[GHC.Types.Double]] #)
  {- Arity: 4, Strictness: <L,U><L,1*U><L,U><L,U(1*C(U),1*C(U),A)>,
     Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Double])
                   (w1 :: [GHC.Types.Double])
                   (w2 :: NeuralNetwork.NeuralNet)
                   (w3 :: NeuralNetwork.ActivationFunction) ->
                 let {
                   ds :: ([[GHC.Types.Double]], [GHC.Types.Double],
                          [GHC.Types.Double], [[GHC.Types.Double]])
                   = case Training.$wrevAcsWis w w3 w2 of ww { (#,#) ww1 ww2 ->
                     case ww1 of wild {
                       [] -> Training.deltas3
                       : ac ds1
                       -> case ww2 of wild1 {
                            [] -> Training.deltas3 : wi wis -> (wild, ac, wi, wis) } } }
                 } in
                 (# case ds of ds1 { (,,,) acs ac wi wis ->
                    GHC.List.reverse1
                      @ [GHC.Types.Double]
                      acs
                      (GHC.Types.[] @ [GHC.Types.Double]) },
                    case ds of ds1 { (,,,) acs ac wi wis ->
                    let {
                      af' :: GHC.Types.Double -> GHC.Types.Double
                      = case w3 of wild { NeuralNetwork.ActivationFunction ds2 ds3 ds4 ->
                        ds3 }
                    } in
                    letrec {
                      func :: [[[GHC.Types.Double]]]
                              -> [[GHC.Types.Double]]
                              -> [[GHC.Types.Double]]
                              -> [[GHC.Types.Double]]
                        <join 3> {- Arity: 3, Strictness: <L,1*U><S,1*U><S,1*U> -}
                      = \ (ds2 :: [[[GHC.Types.Double]]])
                          (ds3 :: [[GHC.Types.Double]])
                          (dlts :: [[GHC.Types.Double]]) ->
                        case ds3 of wild {
                          [] -> dlts
                          : ipv ipv1
                          -> case ds2 of wild1 {
                               [] -> Training.deltas2
                               : wm wms
                               -> case dlts of wild2 {
                                    [] -> Training.deltas2
                                    : del ds4
                                    -> func
                                         wms
                                         ipv1
                                         (GHC.Types.:
                                            @ [GHC.Types.Double]
                                            (letrec {
                                               go :: [[GHC.Types.Double]]
                                                     -> [GHC.Types.Double] -> [GHC.Types.Double]
                                                 {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                                               = \ (ds5 :: [[GHC.Types.Double]])
                                                   (eta :: [GHC.Types.Double]) ->
                                                 case ds5 of wild3 {
                                                   [] -> GHC.Types.[] @ GHC.Types.Double
                                                   : y ys
                                                   -> case eta of wild4 {
                                                        [] -> GHC.Types.[] @ GHC.Types.Double
                                                        : y1 ys1
                                                        -> GHC.Types.:
                                                             @ GHC.Types.Double
                                                             (letrec {
                                                                $wgo2 :: [GHC.Types.Double]
                                                                         -> [GHC.Types.Double]
                                                                         -> GHC.Prim.Double#
                                                                         -> GHC.Types.Double
                                                                  <join 3> {- Arity: 3,
                                                                              Strictness: <S,1*U><L,1*U><S,U>m,
                                                                              Inline: [0] -}
                                                                = \ (w4 :: [GHC.Types.Double])
                                                                    (w5 :: [GHC.Types.Double])
                                                                    (ww :: GHC.Prim.Double#) ->
                                                                  case w4 of wild5 {
                                                                    []
                                                                    -> case y1 of wild6 { GHC.Types.D# y2 ->
                                                                       GHC.Types.D#
                                                                         (GHC.Prim.*## ww y2) }
                                                                    : ipv2 ipv3
                                                                    -> case w5 of wild6 {
                                                                         []
                                                                         -> case y1 of wild7 { GHC.Types.D# y2 ->
                                                                            GHC.Types.D#
                                                                              (GHC.Prim.*## ww y2) }
                                                                         : ipv4 ipv5
                                                                         -> case ipv2 of wild7 { GHC.Types.D# x ->
                                                                            case ipv4 of wild8 { GHC.Types.D# y2 ->
                                                                            $wgo2
                                                                              ipv3
                                                                              ipv5
                                                                              (GHC.Prim.+##
                                                                                 ww
                                                                                 (GHC.Prim.*##
                                                                                    x
                                                                                    y2)) } } } }
                                                              } in
                                                              $wgo2 y del 0.0##)
                                                             (go ys ys1) } }
                                             } in
                                             go
                                               wm
                                               (GHC.Base.map
                                                  @ GHC.Types.Double
                                                  @ GHC.Types.Double
                                                  af'
                                                  ipv))
                                            wild2) } } }
                    } in
                    func
                      (GHC.Base.map
                         @ (NeuralNetwork.Bias, [[GHC.Types.Double]])
                         @ [[GHC.Types.Double]]
                         Training.deltas1
                         (GHC.List.reverse1
                            @ (NeuralNetwork.Bias, NeuralNetwork.Weights)
                            w2
                            (GHC.Types.[] @ (NeuralNetwork.Bias, NeuralNetwork.Weights))))
                      wis
                      (GHC.Types.:
                         @ [GHC.Types.Double]
                         (Training.deltas_go2
                            ac
                            w1
                            (GHC.Base.map @ GHC.Types.Double @ GHC.Types.Double af' wi))
                         (GHC.Types.[] @ [GHC.Types.Double])) } #)) -}
f2f39da7230235df04c65cb52a5c0dee
  $wrevAcsWis ::
    [GHC.Types.Double]
    -> NeuralNetwork.ActivationFunction
    -> NeuralNetwork.NeuralNet
    -> (# [[GHC.Types.Double]], [[GHC.Types.Double]] #)
  {- Arity: 3, Strictness: <L,U><L,1*U(1*C(U),A,A)><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Double])
                   (w1 :: NeuralNetwork.ActivationFunction)
                   (w2 :: NeuralNetwork.NeuralNet) ->
                 let {
                   af :: GHC.Types.Double -> GHC.Types.Double
                   = case w1 of wild { NeuralNetwork.ActivationFunction ds1 ds2 ds3 ->
                     ds1 }
                 } in
                 letrec {
                   $wgo :: [(NeuralNetwork.Bias, NeuralNetwork.Weights)]
                           -> [[GHC.Types.Double]]
                           -> [[GHC.Types.Double]]
                           -> (# [[GHC.Types.Double]], [[GHC.Types.Double]] #)
                     <join 3> {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0] -}
                   = \ (w3 :: [(NeuralNetwork.Bias, NeuralNetwork.Weights)])
                       (ww :: [[GHC.Types.Double]])
                       (ww1 :: [[GHC.Types.Double]]) ->
                     case w3 of wild {
                       [] -> (# ww, ww1 #)
                       : y ys
                       -> case ww of wild1 {
                            []
                            -> case Training.deltas4
                               ret_ty (# [[GHC.Types.Double]], [[GHC.Types.Double]] #)
                               of {}
                            : i ds
                            -> case y of wild2 { (,) bs ws ->
                               let {
                                 wi :: [GHC.Types.Double] = NeuralNetwork.$wcomputeLayer i bs ws
                               } in
                               $wgo
                                 ys
                                 (GHC.Types.:
                                    @ [GHC.Types.Double]
                                    (GHC.Base.map @ GHC.Types.Double @ GHC.Types.Double af wi)
                                    wild1)
                                 (GHC.Types.: @ [GHC.Types.Double] wi ww1) } } }
                 } in
                 $wgo
                   w2
                   (GHC.Types.:
                      @ [GHC.Types.Double]
                      w
                      (GHC.Types.[] @ [GHC.Types.Double]))
                   (GHC.Types.[] @ [GHC.Types.Double])) -}
e845e9c270fef64cfeef01e086bef811
  cost' :: GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Double) (w1 :: GHC.Types.Double) ->
                 case w of ww { GHC.Types.D# ww1 ->
                 case w1 of ww2 { GHC.Types.D# ww3 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==## ww3 1.0##) of wild {
                   GHC.Types.False -> GHC.Types.D# (GHC.Prim.-## ww1 ww3)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=## ww1 ww3) of wild1 {
                        GHC.Types.False -> GHC.Types.D# (GHC.Prim.-## ww1 ww3)
                        GHC.Types.True -> GHC.Types.D# 0.0## } } } }) -}
f8e692728b231538d007c01fe367b150
  deltas ::
    [GHC.Types.Double]
    -> [GHC.Types.Double]
    -> NeuralNetwork.NeuralNet
    -> NeuralNetwork.ActivationFunction
    -> ([[GHC.Types.Double]], [[GHC.Types.Double]])
  {- Arity: 4, Strictness: <L,U><L,1*U><L,U><L,U(C(U),C(U),A)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: [GHC.Types.Double])
                   (w1 :: [GHC.Types.Double])
                   (w2 :: NeuralNetwork.NeuralNet)
                   (w3 :: NeuralNetwork.ActivationFunction) ->
                 case Training.$wdeltas w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
ce83ffc501495a4473aaaf4ac21c2da4
  deltas1 ::
    (NeuralNetwork.Bias, [[GHC.Types.Double]]) -> [[GHC.Types.Double]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (NeuralNetwork.Bias, [[GHC.Types.Double]])) ->
                 case x of wild { (,) ds1 y ->
                 Data.OldList.transpose @ GHC.Types.Double y }) -}
90d3b888d2bec2f56f73e7750869b3c0
  deltas2 :: [[GHC.Types.Double]]
  {- Strictness: x -}
d3c325a509acd95f2bbf2d32f30cb154
  deltas3 ::
    ([[GHC.Types.Double]], [GHC.Types.Double], [GHC.Types.Double],
     [[GHC.Types.Double]])
  {- Strictness: x -}
d0b4edf81324697cdb72b8828fcad4c1
  deltas4 :: ([[GHC.Types.Double]], [[GHC.Types.Double]])
  {- Strictness: x -}
2131f3e080d18ec04f929efd661f311e
  deltas_go2 ::
    [GHC.Types.Double]
    -> [GHC.Types.Double] -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,1*U> -}
987de44db3175748c7195a9f1211816e
  learn ::
    [GHC.Types.Double]
    -> [GHC.Types.Double]
    -> NeuralNetwork.NeuralNet
    -> NeuralNetwork.ActivationFunction
    -> NeuralNetwork.NeuralNet
  {- Arity: 4, Strictness: <L,U><L,1*U><S,U><L,U(C(U),C(U),A)>,
     Unfolding: (\ (input :: [GHC.Types.Double])
                   (expected :: [GHC.Types.Double])
                   (net :: NeuralNetwork.NeuralNet)
                   (af :: NeuralNetwork.ActivationFunction) ->
                 let {
                   ds :: ([[GHC.Types.Double]], [[GHC.Types.Double]])
                   = case Training.$wdeltas
                            input
                            expected
                            net
                            af of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 let {
                   dlts :: [[GHC.Types.Double]]
                   = case ds of wild { (,) acs dlts1 -> dlts1 }
                 } in
                 Training.learn_go
                   net
                   dlts
                   (GHC.List.zipWith3
                      @ [[GHC.Types.Double]]
                      @ [GHC.Types.Double]
                      @ [GHC.Types.Double]
                      @ [[GHC.Types.Double]]
                      Training.learn1
                      (GHC.Base.map
                         @ (NeuralNetwork.Bias, NeuralNetwork.Weights)
                         @ [[GHC.Types.Double]]
                         (Data.Tuple.snd @ NeuralNetwork.Bias @ NeuralNetwork.Weights)
                         net)
                      (case ds of wild { (,) acs dlts1 -> acs })
                      dlts)) -}
8053eb4e59922b63f7f6f91d6a37837e
  learn1 ::
    [[GHC.Types.Double]]
    -> [GHC.Types.Double] -> [GHC.Types.Double] -> [[GHC.Types.Double]]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,1*U>,
     Unfolding: (\ (wvs :: [[GHC.Types.Double]])
                   (a :: [GHC.Types.Double])[OneShot]
                   (d1 :: [GHC.Types.Double])[OneShot] ->
                 GHC.List.zipWith
                   @ [GHC.Types.Double]
                   @ GHC.Types.Double
                   @ [GHC.Types.Double]
                   (\ (wv :: [GHC.Types.Double]) (d2 :: GHC.Types.Double)[OneShot] ->
                    GHC.List.zipWith
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      GHC.Float.minusDouble
                      wv
                      (GHC.Base.map
                         @ GHC.Types.Double
                         @ GHC.Types.Double
                         Training.learn2
                         (GHC.Base.map
                            @ GHC.Types.Double
                            @ GHC.Types.Double
                            (GHC.Float.timesDouble d2)
                            a)))
                   wvs
                   d1) -}
af0512dc59b124bad42d7a32640514ff
  learn2 :: GHC.Types.Double -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: GHC.Types.Double) ->
                 case ds1 of wild3 { GHC.Types.D# y ->
                 GHC.Types.D# (GHC.Prim.*## 2.0e-3## y) }) -}
c8fd466f42ec1007ce26431c61a0e1b1
  learn_go ::
    [(NeuralNetwork.Bias, NeuralNetwork.Weights)]
    -> [[GHC.Types.Double]]
    -> [[[GHC.Types.Double]]]
    -> [([GHC.Types.Double], [[GHC.Types.Double]])]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,1*U> -}
926d05eada4b469ae6b393b4cae6a3cd
  learningRate :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.D# 2.0e-3##) -}
6e242ecf6b0890455c0262e7fd4b1490
  revAcsWis ::
    [GHC.Types.Double]
    -> NeuralNetwork.ActivationFunction
    -> NeuralNetwork.NeuralNet
    -> ([[GHC.Types.Double]], [[GHC.Types.Double]])
  {- Arity: 3, Strictness: <L,U><L,1*U(1*C(U),A,A)><S,1*U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [GHC.Types.Double])
                   (w1 :: NeuralNetwork.ActivationFunction)
                   (w2 :: NeuralNetwork.NeuralNet) ->
                 case Training.$wrevAcsWis w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

